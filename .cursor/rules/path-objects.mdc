---
description: Path object usage standards for filesystem operations
globs: ["**/*.py"]
alwaysApply: false
---

# Path Object Usage Standards

## Core Principle

**Always use `pathlib.Path` for filesystem operations**

## Usage

```python
from pathlib import Path

# ✅ Good
data_dir = Path("data/raw")
file_path = data_dir / "accounts.parquet"
if file_path.exists():
    content = file_path.read_text()

def process_file(input_path: Path, output_path: Path) -> Path:
    return output_path

# ❌ Bad
data_dir = "data/raw"
file_path = data_dir + "/accounts.parquet"
file_path = f"{data_dir}/accounts.parquet"
file_path = os.path.join(data_dir, "accounts.parquet")
```

## External APIs

```python
# Convert to string only at API boundary
database_path = Path("data/db.duckdb")
conn = duckdb.connect(database_path)  # Many libs accept Path directly

# If string needed, convert at boundary
some_library.process(str(database_path))
```

## Configuration

```python
@dataclass
class Config:
    source_path: Path = Path("data/raw")
    database_path: Path = Path("data/db.duckdb")
```

## Benefits

- Type safety with compile-time checking
- Cross-platform path separators
- Rich API (`.exists()`, `.mkdir()`, `.glob()`, etc.)
- Better error messages
