---
description: Python testing standards and best practices using pytest
globs: ["tests/**/*", "**/*test*.py", "conftest.py"]
alwaysApply: false
---

# Python Testing Standards

## Framework & Organization

- **Pytest**: Use [pytest](https://docs.pytest.org/) for all testing
- **Naming**: Files `test_*.py`, functions `test_*()`, classes `TestClassName`
- **Fixtures**: Create reusable fixtures in `conftest.py`
- **Mocking**: Use `mocker: MockerFixture` for external dependencies
- **Coverage**: Aim for >80% on business logic

## Test Markers & Types

```python
@pytest.mark.unit  # Fast unit tests (default)
@pytest.mark.integration  # Tests requiring external systems
@pytest.mark.slow  # Long-running tests

# Fixture type annotations
def test_example(tmp_path: Path, mocker: MockerFixture, caplog):
    pass
```

## Running Tests

```bash
uv run pytest tests/ -v  # All tests
uv run pytest tests/ -v -m "not integration"  # Unit only
uv run pytest tests/ -v -m integration  # Integration only
uv run pytest tests/test_file.py -v  # Specific file
uv run pytest tests/ --cov=src/moneybin --cov-report=html  # With coverage
```

## Mocking Strategy

- **Mock external dependencies**: APIs, databases, file systems
- **Use real objects** for internal business logic when possible
- CLI tests: mock business logic classes (tested separately)

## Best Practices

- **Arrange-Act-Assert**: Structure all tests clearly
- **Test one thing**: Each test verifies single behavior
- **Independent tests**: No shared state between tests
- **Descriptive names**: Test name explains the scenario
- **Environment isolation**: Use `monkeypatch` for env vars
- **Test-specific config**: Override settings for tests

## Coverage Goals

- Business Logic: 90%+ coverage
- CLI Commands: Focus on CLI-specific paths only
- Integration: Critical user workflows end-to-end
