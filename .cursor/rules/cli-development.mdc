---
description: CLI command development patterns and security standards for user-facing commands
globs: ["**/cli/**/*.py", "src/**/commands/**/*.py"]
alwaysApply: false
---

# CLI Development Standards

## Core Principle

CLI commands are **thin wrappers** around well-tested business logic. Focus on user experience, argument parsing, and error handling - not complex functionality.

## Standard CLI Pattern

```python
@app.command("command-name")
def command_function(source_path: Path = typer.Option(..., help="Description")) -> None:
    """Clear command description."""
    setup_logging(cli_mode=True)  # 1. Setup logging
    try:
        config = ConfigClass(source_path=source_path)  # 2. Create config
        processor = BusinessClass(config)  # 3. Initialize business logic
        results = processor.main_operation()  # 4. Execute
        logger.info(f"âœ… Processed {len(results)} records")  # 5. Display results
    except FileNotFoundError as e:
        logger.error(f"âŒ {e}")
        raise typer.Exit(1) from e
```

## Security - Input Validation

**Path Validation**: Check for shell injection chars: `;`, `|`, `&`, `$`, `` ` ``
**String Parameters**: Validate before subprocess execution to prevent injection
**Command Building**: Use list format `["cmd", "arg"]`, never string interpolation

## Error Handling

- Catch **specific exceptions** (FileNotFoundError, PermissionError, etc.)
- Use `raise typer.Exit(code) from e` for proper error chaining
- **Exit codes**: 0 (success), 1 (general error), 2+ (command-specific)
- Provide user-friendly error messages with emoji: âŒ, ðŸ’¡, âœ…, âš ï¸

## Subprocess Execution

```python
# Build command safely as list (never string interpolation)
cmd = ["dbt", "run", "--project-dir", validated_dir]
result = subprocess.run(cmd, capture_output=True, text=True, check=False)
if result.returncode != 0:
    logger.error(f"âŒ Failed with code {result.returncode}")
    raise typer.Exit(result.returncode)
```

## User Experience

- Use emoji in output: ðŸš€ âœ… âŒ âš ï¸ ðŸ’¡ ðŸ“Š ðŸ“¥ ðŸ’¾ ðŸ”„
- Provide progress updates for long operations
- Use kebab-case for command names
- Clear help text for all commands and options
- Consistent parameter naming across commands

## Separation of Concerns

**âŒ DON'T**: Complex business logic in CLI commands
**âœ… DO**: Delegate to business logic classes

```python
# Good: CLI maps args to config, delegates to business logic
@app.command("load")
def load_data(source: Path = typer.Option(...)) -> None:
    config = LoadingConfig(source_path=source)
    loader = DataLoader(config)
    results = loader.load_all()
    logger.info(f"âœ… Loaded {len(results)} records")
```

## Testing

- Test argument parsing with mocked business logic
- Test exit codes and error messages
- Test input validation functions
- Don't test business logic in CLI tests (test separately)
